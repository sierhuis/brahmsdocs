<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejenta - Language Specification - Delete (DEL) - Description</title>
    <link rel="stylesheet" type="text/css" href="../../style/modern_style.css">
    <link rel="SHORTCUT ICON" href="../../logo.ico">
    <script type="text/javascript" src="../doctree.jsc"></script>
    <script type="text/javascript" src="../../scripts/treescript.jsc"></script>
</head>
<body onload="open_folder_to_page('OUT0t,OUT2t,OUT28t,DT96');">

    <header>
        <img src="../../images/aislogo_600_small.jpg" alt="Ejenta Logo" class="logo">
        <nav class="top-nav">
            <ul>
                <li><a href="../../index.htm">Home</a></li>
                <li><a href="../../products/index.htm">Products</a></li>
                <li><a href="../index.htm" class="active">Documentation</a></li>
                <li><a href="../../download/index.htm">Download</a></li>
                <li><a href="../../support/index.htm">Support</a></li>
            </ul>
        </nav>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <nav class="side-nav">
                <h2>Documentation</h2>
                <div class="tree-container">
                    <script language="javascript">
                        <!--
                        createDocumentTree("../");
                        -->
                    </script>
                </div>
            </nav>
        </aside>

        <main class="content">
            <div class="doc-header">
                <h1>Language Specification - Delete (DEL) - Description</h1>
            </div>
            <nav class="doc-nav">
                <a href="ls_tdf_dsc.htm" class="prev">Prev</a>
                <div class="doc-sub-nav">
                    <span class="active">Description</span>
                    <a href="ls_del_stx.htm">Syntax</a>
                    <a href="ls_del_sem.htm">Semantics</a>
                </div>
                <a href="ls_kwd.htm" class="next">Next</a>
            </nav>
            <hr>
            <section class="doc-content">
                <p>The delete action is an action used to reclaim memory obtained for agents, objects and conceptual objects created at simulation/run-time. The delete action cannot be used on agents, objects, or conceptual objects that are created at design-time. The deletion of an agent, object, or conceptual object results in the deregistration of the element from the directory service (in case of a distributed system), removal of references to the element for the calling agent/object, and removal of the element from the model. Elements declared as part of the model at compile time cannot be deleted. Delete operations on static model elements are no-ops and will cause the Brahms virtual machine to print a warning.</p>

                <h3>Element Creation and References</h3>
                <p>Agents, objects and conceptual objects are created either when a model is loaded when they are defined as part of the model, when created using one of the create activities or created through the Java API. In distributed mode these elements are registered in the directory service. References to these elements are made in beliefs, facts, and as part of variable contexts maintained for frames defining variables that have their repeat property set to false. References to agents or objects are held using beliefs by either these agents or objects themselves (beliefs about themselves) or references to agents, objects, and conceptual objects are held by other agents or objects (beliefs about those elements). The world state maintains references to elements through facts. In distributed mode beliefs referencing these elements can be communicated to a remote agent or object. Objects that have no frames can be communicated by value to a remote agent or object effectively creating a duplicate copy of the object (this happens when communicating CommunicativeActs).</p>

                <h3>Reference Counting</h3>
                <p>To identify when an object can truly be deleted the Brahms virtual machine maintains a reference count for every element per agent/object holding beliefs with a reference to the element.</p>
                <p>The reference count will go up:</p>
                <ol>
                    <li>when an agent/object creates the element</li>
                    <li>when an agent/object asserts a belief with a reference to the element</li>
                    <li>when an external agent acquires a memory reference (IActiveInstance::acquireMemoryReference(), IConceptualInstance::acquireMemoryReference())</li>
                </ol>
                <p>The count will go down:</p>
                <ol>
                    <li>when an agent invokes 'delete &lt;element&gt;'</li>
                    <li>when an external agent releases a memory reference (IActiveInstance::releaseMemoryReference(), IConceptualInstance::releaseMemoryReference())</li>
                </ol>
                <p>Notes regarding the reference count:</p>
                <ol>
                    <li>The agent/object that creates the element and that asserts beliefs with references to the element will only increment the reference count by 1, not 2. Any agent/object can at maximum hold one reference to the element.</li>
                    <li>References held by remote agents/objects are not counted since we can't guarantee network availability, remote system uptime, and proper notifications of element deletion in a remote Brahms virtual machine.</li>
                    <li>Object copies (due to transfer by value) will have their own reference count in the Brahms virtual machine in which they were created as a copy and will therefore require separate deletion.</li>
                    <li>The element for which a reference count is being maintained has itself no impact on the reference count even when beliefs about the element are being asserted in that element about that element.</li>
                    <li>Multiple invocations of the delete action on the same element by the same agent/object will have no effects on the reference count. Only the first delete will cause the reference count to go down by 1.</li>
                    <li>If an external agent creates a new dynamic element automatically a reference to it for the external agent will be created! This means that the external agent must release any references to elements it creates using either (IActiveInstance::releaseMemoryReference() or IConceptualInstance::releaseMemoryReference().</li>
                    <li>When an external agent is notified of a belief (via invocation on onReceive) no automatic reference is obtained for any of the dynamic elements referenced in the belief. It is up to the external agent to acquire and release the necessary references.</li>
                </ol>

                <h3>Hard and Soft Reference</h3>
                <p>For the purposes of element deletion the Brahms virtual machine differentiates between hard and soft references.</p>
                <p>A hard reference is a reference held by an agent/object that has frames. This agent/object is able to invoke a delete of the element at the appropriate time.</p>
                <p>A soft reference is a reference held by an object that has no reasoning capabilities (a data object). It has beliefs in its beliefset that reference the element.</p>
                <p>If there are no more hard references to an element and only soft references then the element will only be deleted when all agents/objects that have references to the element to be deleted themselves are marked for deletion and have no more hard references to those elements. If object O1 and object O2 have references to eachother in their beliefsets under normal circumstances neither would ever be deleted since the reference count never goes to 0. Assuming O1 and O2 are data objects then the references to eachother would be soft references. If no hard references exist for either of these two objects then the Brahms virtual machine will garbage collect them and perform the final deletion on both O1 and O2.</p>

                <h3>Results of a Delete</h3>
                <p>When an agent or object invokes a delete on an element E the Brahms virtual machine will take the following actions:</p>
                <ol>
                    <li>Retract all beliefs in which E is referenced, whether it be on the left hand side or right hand side of the belief.</li>
                    <li>Remove all previously executed frame contexts that hold a reference to E in a variable context when the frame has the repeat property set to false.</li>
                    <li>Reduce the hard reference count by 1 for the caller. If delete was invoked earlier the reference count remains unchanged.</li>
                </ol>

                <h3>When the Hard Reference Count goes to 0</h3>
                <p>When there are no soft references to the element E:</p>
                <ol>
                    <li>Retract all facts referencing E, whether it be on the left hand side or right hand side of the fact.</li>
                    <li>Deregister E from the directory service.</li>
                    <li>Remove E from the model.</li>
                </ol>
                <p>When there are soft references to the element E:</p>
                <ol>
                    <li>Mark E for garbage collection.</li>
                    <li>Verify all soft references that reference E and delete any elements marked for garbage collection that only had a soft reference remaining to E.</li>
                </ol>

                <h3>Can an element be brought back?</h3>
                <p>Yes. If an object still has soft references the facts about the object are not yet retracted. This means that object detection is still possible. When an agent/object detects the object and asserts a new belief about the object the hard reference count is incremented and the object is no longer marked for garbage collection.</p>

                <h3>Remote References</h3>
                <p>If an element E is created in Brahms virtual machine VM1 and a belief referencing E is communicated to an agent/object in Brahms virtual machine VM2, E is deleted in VM1 and VM1 no longer holds any hard or soft references to E then the element will be deleted. The reference to E held in VM2 becomes stale. Any operations on E in VM2 can result in exceptions. Operations that cause exceptions:</p>
                <ol>
                    <li>reading of beliefs from E</li>
                    <li>communication of beliefs referencing E to a remote agent, an exception will be raised in the receiving virtual machine when it attempts to resolve E by looking it up in the directory service (E is longer registered in the directory service and cannot be located)</li>
                </ol>
                <p>If E is a data object that was communicated by value then a separate reference count is maintained for this 'copy'. NOTE however that this copy is not registered in the directory service and if its original has been deleted then exceptions will be raised when:</p>
                <ol>
                    <li>beliefs referencing E are communicated to a remote agent/object. The exception is raised in the receiving virtual machine when it attempts to resolve E using the directory service (E is longer registered in the directory service and cannot be located)</li>
                </ol>
                <p>Note that transmitting E in its entirety by value will cause no problems since when transmitting the entire object all relevant information to create a copy of it will be included as part of the message. This is generally only done with CommunicativeActs. It is safe to communicate a copy of a CommunicativeAct using a communicate activity to a remote agent even if its original has been deleted. Just communicating a belief about the CommunicativeAct to a remote agent however will raise an exception in the receiving virtual machine.</p>
                <p>Any agent/object holding references to a copy of an element must call 'delete' for that element to ensure that it is deleted just like any other element.</p>
                <p>Invoking delete on an element E for which the original does not exist in the virtual machine or where E is not a copy the delete will:</p>
                <ol>
                    <li>Retract all beliefs referencing E from the beliefset of the agent/object invoking delete</li>
                    <li>Remove all previously executed frame contexts that hold a reference to E in a variable context when the frame has the repeat property set to false.</li>
                </ol>
                <p>There will be no reference count modifications since the original/copy is not held in that virtual machine.</p>
            </section>
        </main>
    </div>

    <footer>
        <hr>
        <p>Copyright &#169; 2012-2025 Ejenta, Inc. All rights reserved.</p>
        <p>Last modified: August 25, 2025.</p>
    </footer>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejenta - Language Specification - Collection Types</title>
    <link rel="stylesheet" type="text/css" href="../../style/modern_style.css">
    <link rel="SHORTCUT ICON" href="../../logo.ico">
    <script type="text/javascript" src="../doctree.jsc"></script>
    <script type="text/javascript" src="../../scripts/treescript.jsc"></script>
</head>
<body onload="open_folder_to_page('OUT0t,DT95');">

    <header>
        <img src="../../images/aislogo_600_small.jpg" alt="Ejenta Logo" class="logo">
        <nav class="top-nav">
            <ul>
                <li><a href="../../index.htm">Home</a></li>
                <li><a href="../../products/index.htm">Products</a></li>
                <li><a href="../index.htm" class="active">Documentation</a></li>
                <li><a href="../../download/index.htm">Download</a></li>
                <li><a href="../../support/index.htm">Support</a></li>
            </ul>
        </nav>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <nav class="side-nav">
                <h2>Documentation</h2>
                <div class="tree-container">
                    <script language="javascript">
                        <!--
                        createDocumentTree("../");
                        -->
                    </script>
                </div>
            </nav>
        </aside>

        <main class="content">
            <div class="doc-header">
                <h1>Language Specification - Collection Types</h1>
            </div>
            <nav class="doc-nav">
                <a href="ls_unknown.htm" class="prev">Prev</a>
                <a href="ls_kwd.htm" class="next">Next</a>
            </nav>
            <hr>
            <section class="doc-content">
                <p>The Brahms language lacked support for multi-valued attributes; only relations allowed for multiple values. To address this issue, the language now supports collection types. The type currently supported in the language is the map type.</p>

                <h2>Map</h2>
                <p>The map collection type is a type that can only be used as part of the declaration of attributes. It allows for the assignment of multiple values to the attribute where each value is addressable using an index or key. The attribute's values are index/value or key/value pairs. The index or key can be any positive integer or string value.</p>

                <h3>Declaring Maps</h3>
                <p>A map is declared by declaring an attribute of type 'map'.</p>
                <pre><code>    attributes:
        public map myMap;</code></pre>

                <h3>Creating Map Values</h3>
                <p>A map value is an index/value or key/value pair. Where we specify index, we also imply key. Map values, like any other attribute values, are represented as beliefs and/or facts. A map is created when at least one belief or fact exists defining a map value. The creation of these beliefs/facts is done like any other beliefs/facts, through initial beliefs/facts or by concluding the beliefs. The index of a map value can only be an integer or a string. The value as part of the index/value pair can be any value of any type.</p>
                <p>Using initial beliefs/facts, map values can be created as:</p>
                <pre><code>    initial_beliefs:
        (current.myMap(1) = 10);                  // int
        (current.myMap(2) = 100L);                 // long
        (current.myMap(240) = 10.0);               // double
        (current.myMap(3) = true);                 // boolean
        (current.myMap(4) = SomeSymbol);           // symbol
        (current.myMap(5) = "Some String");        // string
        (current.myMap(6) = MyAgent);              // agent
        (current.myMap(7) = MyObject);             // object
        (current.myMap(8) = unknown);              // unknown
        (current.myMap("intValue") = 10);          // int
        (current.myMap("longValue") = 100L);       // long
        (current.myMap("doubleValue") = 10.0);     // double
        (current.myMap("booleanValue") = true);    // boolean
        (current.myMap("symbolValue") = SomeSymbol);   // symbol
        (current.myMap("stringValue") = "Some String"); // string
        (current.myMap("agentReference") = MyAgent);   // agent
        (current.myMap("objectReference") = MyObject); // object
        (current.myMap("unknownValue") = unknown);     // unknown

    initial_facts:
        (current.myMap(1) = 10);                   // int
        (current.myMap(2) = 100L);                  // long
        (current.myMap(240) = 10.0);                // double
        (current.myMap(3) = true);                  // boolean
        (current.myMap(4) = SomeSymbol);            // symbol
        (current.myMap(5) = "Some String");         // string
        (current.myMap(6) = MyAgent);               // agent
        (current.myMap(7) = MyObject);              // object
        (current.myMap(8) = unknown);               // unknown
        (current.myMap("intValue") = 10);           // int
        (current.myMap("longValue") = 100L);        // long
        (current.myMap("doubleValue") = 10.0);      // double
        (current.myMap("booleanValue") = true);     // boolean
        (current.myMap("symbolValue") = SomeSymbol);    // symbol
        (current.myMap("stringValue") = "Some String");  // string
        (current.myMap("agentReference") = MyAgent);    // agent
        (current.myMap("objectReference") = MyObject);  // object
        (current.myMap("unknownValue") = unknown);      // unknown</code></pre>
                <p>The numeric indices do not need to be sequential; they can be any valid positive integer value. Any string can be used for the index of a map as well. Generally, when a numeric index value is used, we refer to it as an index; when a string index value is used, we refer to it as a key. The numeric value can be referred to as a key and the string value as an index as well, so in this document, we will just refer to all of them as an index.</p>
                <p>Besides defining map values through initial beliefs and facts, the map values can also be created using consequences. The following consequences show the most simplistic way to create new map values. Just like with initial beliefs and facts, any value can be assigned to an index of a map.</p>
                <pre><code>    conclude((current.myMap(100) = "Some Value"));
    conclude((current.myMap("newValue") = 25.0));</code></pre>
                <p>It is also possible to change the values of an index for a map. The value can be changed to any other value; it does not necessarily have to be of the same value type as the previously assigned value. The following consequences show examples of this: the first consequence just changes the value, not the type (both strings), the second consequence changes the value type from double to boolean.</p>
                <pre><code>    conclude((current.myMap(100) = "Some Other Value"));
    conclude((current.myMap("newValue") = true));</code></pre>
                <p>When a value is replaced, the virtual machine will first retract the old belief/fact for that index/value pair, followed by asserting the new belief/fact.</p>
                <p>Variables declared for the workframe or thoughtframe can also be used for either or both the index and value in a consequence. A variable that is intended to be used for the index must be of type int or string. The variables must also be bound to a valid value, or the virtual machine will generate an error.</p>
                <pre><code>    variables:
        foreach(string) sKey;
        foreach(symbol) sSymbolValue;
        foreach(int) nIntValue;
    when( ... )
    do {
        conclude((current.myMap(25) = sSymbolValue));
        conclude((current.myMap(sKey) = nIntValue));
    } // end do</code></pre>
                <p>Parameters declared for activities can also be used for either or both the index and value in a consequence. They work in the same way as variables. The parameter must be resolvable to a value, either an actual value passed as an argument for the parameter or a variable passed as an argument for the parameter that is bound to a value. An error is generated by the virtual machine if this is not the case. Parameters used for the index of a map value must be declared to be of type int or string.</p>
                <pre><code>    composite_activity myActivity(string key, 
                                     symbol symbolValue, 
                                     int intValue) {
        workframes:
            workframe wf_myWorkframe {
                do {
                    conclude((current.myMap(25) = symbolValue));
                    conclude((current.myMap(key) = intValue));
                } // end do
            } // wf_myWorkframe
    } // myActivity</code></pre>
                <p>It is also possible to assign values to an index of a map by resolving a belief or fact on the right-hand side of a consequence. The right-hand side can be an object/attribute tuple or it can consist of a reference to the index of a map that is resolved to a value. Again, variables can be used anywhere in these consequences, both on the left and right-hand side.</p>
                <pre><code>    conclude((current.myMap(30) = current.location));
    conclude((current.myMap("value") = current.myMap("intValue")));</code></pre>
                <p>It is <b><i>not</i></b> possible to assign a map to an index of a map. The compiler will not permit this and will generate a compiler error. The following is not permitted:</p>
                <pre><code>    conclude((current.myMap("someMap") = current.myMap));</code></pre>

                <h3>Using Map Values in Preconditions</h3>
                <p>The use of map values in preconditions is no different than using regular values. Preconditions now allow you to specify an index for attributes of type map to allow for the proper matching of beliefs in the preconditions. Variables can be declared for both the index and the index value.</p>
                <pre><code>    knownval(current.myMap(1) = 10)
    knownval(current.myMap("stringValue") = "Some String")
    knownval(current.myMap(1) = current.myMap("intValue"))
    knownval(current.myMap(nIndexVar) = 10)
    knownval(nValue = current.myMap(nIndexVar))
    knownval(current manages current.myMap("agentReference"))
    knownval(current manages current.myMap(nIndexVar))
    knownval(current.myMap = unknown)
    known(current.myMap)
    known(current.myMap(1))
    known(current.myMap(nIndexVar))</code></pre>
                <p>All of these preconditions are valid. The virtual machine ensures that the variables used in these preconditions get the proper matching binding. A few notes about the known preconditions: In the case of <code>known(current.myMap)</code>, the precondition will only evaluate to true if the belief <code>(current.myMap = unknown)</code> exists. If beliefs with index/value pairs exist for the map, then that precondition evaluates to false. For the known precondition specifying the index, the precondition will only evaluate to true if the index value matches with a belief that has that same index value, or it evaluates to true for any index value that is matched for the index if a variable is specified for the index that has not been bound in earlier preconditions.</p>
                <p>Note that since map values are not typed, the virtual machine will do run-time type checking to make sure that any values resulting from the evaluation of an object-attribute-index expression is type-compatible with the opposite side of the condition if an attribute or variable is specified or if a relation is used.</p>
                <pre><code>    attributes:
        public int numEmployees;
    relations:
        public BaseGroup manages;

    knownval(current.numEmployees = current.myMap("stringValue"))
    knownval(current manages current.myMap("intValue"))</code></pre>
                <p>These preconditions will generate warnings in the log file and will evaluate to false, since the map value for the "stringValue" index is a string and not an integer, and since the map value for "intValue" is an integer and not an agent reference with the agent being a member of BaseGroup.</p>

                <h3>Using Map Values in Consequences</h3>
                <p>Map values can be used in the right-hand side of consequences to conclude a new value of a single-valued attribute or to conclude a new value of a relation. The values of index/value pairs are not strongly typed for maps and any value is supported. However, attributes that are not of a collection type and relations are strongly typed. Care is therefore required when assigning a value to an attribute using a map value.</p>
                <pre><code>    attributes:
        public int numEmployees;

    conclude((current.numEmployees = current.myMap("intValue")));
    conclude((current.numEmployees = current.myMap("doubleValue")));</code></pre>
                <p>The first consequence will succeed since the agent currently believes the integer value 10 for the index "intValue" for myMap, which is of the correct type for numEmployees. For the second one, however, the virtual machine will generate an error in the log file since double values are not type-compatible with integers, and the double value can therefore not be assigned to numEmployees.</p>
                <pre><code>    relations:
        public BaseGroup manages;

    conclude((current manages current.myMap("agentReference")));
    conclude((current manages current.myMap("objectReference")));</code></pre>
                <p>In this case with the use of relations, the first consequence again will succeed since the agent currently believes MyAgent as the value for the index "agentReference" for myMap, which is an agent that is always a member of BaseGroup and is therefore type-compatible with the manages relation. The second consequence, however, returns MyObject from the map when using the index "objectReference", which is of type BaseClass and not type-compatible with BaseGroup. The virtual machine will generate an error in the log file and not execute the consequence.</p>

                <h3>Copying Maps</h3>
                <p>The language makes it easy to copy the map values of one map to another map. This is done by using consequences.</p>
                <p>Assume that we have two attributes declared, myMap and myMapCopy, both of type map. Also assume that we have assigned values to myMap already as we've shown in the examples for initial beliefs and assume that this consequence is executed for an agent.</p>
                <pre><code>    conclude((current.myMapCopy = current.myMap));</code></pre>
                <p>This consequence will copy all beliefs with the index/value pairs for myMap to myMapCopy, creating the identical index/value pairs for myMapCopy. If myMapCopy had any indices that were identical to those in myMap, then the values for those indices for myMapCopy will be replaced with those of myMap.</p>
                <p>Before the conclude, we have the following beliefs:</p>
                <pre><code>    (current.myMap(1) = 10)
    (current.myMap("stringValue") = "Some String")
    (current.myMapCopy(1) = 50)</code></pre>
                <p>After the conclude, we have the following beliefs:</p>
                <pre><code>    (current.myMap(1) = 10)
    (current.myMap("stringValue") = "Some String")
    (current.myMapCopy(1) = 10)
    (current.myMapCopy("stringValue") = "Some String")</code></pre>
                <p>The value 50 for index 1 for myMapCopy was retracted and the new value 10 was asserted, and a new belief for index "stringValue" with value "Some String" was asserted for myMapCopy. Note that since we didn't specify belief or fact certainties, both were defaulted to 100% and therefore also facts were asserted for the myMapCopy index/value pairs.</p>

                <h3>Clearing Maps</h3>
                <p>A consequence is also used to clear a map of all of its index/value pairs. This is done by concluding the value unknown for the map attribute without specifying an index.</p>
                <pre><code>    conclude((current.myMap = unknown));</code></pre>
                <p>This retracts all index/value pair beliefs and facts for myMap and asserts the new belief/fact:</p>
                <pre><code>    (current.myMap = unknown)</code></pre>
                <p>When a new index/value pair for this cleared map is concluded, then first the unknown belief/fact for that map is retracted, followed by the assertion of the new index/value pair.</p>

                <h3>Communicating Maps/Map Values</h3>
                <p>Using broadcast and communicate activities, it is possible to communicate beliefs from one agent to another. Since index/value pairs for maps are represented as beliefs, they are communicated in the same way.</p>
                <p>In the transfer definitions of the broadcast and communicate activities, either single map values can be communicated or an entire map.</p>
                <pre><code>    communicate communicateMapValues(string key, SomeGroup agt) {
        ...
        about:
            send(current.myMap(1) = unknown),
            send(current.myMap("intValue") = unknown),
            send(current.myMap(key) = unknown),
            send(current.myMap = unknown),
            receive(agt.otherMap(1) = unknown),
            receive(agt.otherMap("intValue") = unknown),
            receive(agt.otherMap(key) = unknown),
            receive(agt.otherMap = unknown);
    } // communicateMapValues</code></pre>
                <p>When an index is specified, only the belief matching the OA(index) will be sent/received. The index can be specified using a parameter declared for the activity. If no index is specified for the map, all beliefs about the map will be sent/received. This makes it easy to send/receive the entire contents of a map.</p>

                <h3>Detecting Map Values</h3>
                <p>Map values can also be detected in detectables and can be used to trigger detectable actions. They operate in a similar way as in preconditions. For detection of facts, the left-hand side of the detectable condition is relevant. On that left-hand side can be specified whether a single map value is to be detected by specifying the index for the map value to be detected or whether all map values need to be detected.</p>
                <pre><code>    detect((current.myMap(1) = unknown));
    detect((current.myMap("intValue") = unknown));
    detect((current.myMap(someVariable) = unknown));
    detect((current.myMap = unknown));</code></pre>
                <p>The first three detectable conditions detect a single value, with the third one using a variable to specify the index to be detected. That variable must have been bound in the preconditions. The last detectable condition detects all map values for myMap.</p>
                <p>For triggers, the right-hand side value must match with the detected belief or belief matching the left-hand side. The right-hand side of the detectable can also specify a reference to a map value. The following are all valid detectable/trigger conditions.</p>
                <pre><code>    detect((current.myMap(1) = current.myMap("intValue")));
    detect((current.numEmployees = current.myMap(1)));
    detect((current manages current.myMap("agentReference")));</code></pre>
                <p>In the last two conditions, there is a potential for type mismatch. For the condition using an attribute on the left-hand side, no warnings or errors are generated if there is a type mismatch. The virtual machine just compares the right-hand side value of the belief matching <code>(current.numEmployees = ?)</code> with the right-hand side value of the belief <code>(current.myMap(1) = ?)</code>. If they match, the detectable action is triggered; if not, the action is not performed. For the condition using a relation, a warning is generated if the map value is not type-compatible with the relation due to the fact that relations are handled differently than attributes by the virtual machine. The detectable action is not triggered in that case, only when the resulting reference matches that of the right-hand side reference of the belief <code>(current manages ?)</code>.</p>
            </section>
        </main>
    </div>

    <footer>
        <hr>
        <p>Copyright &#169; 2012-2025 Ejenta, Inc. All rights reserved.</p>
        <p>Last modified: August 25, 2025.</p>
    </footer>

</body>
</html>
